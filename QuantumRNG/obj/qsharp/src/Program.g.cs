//------------------------------------------------------------------------------
// <auto-generated>                                                             
//     This code was generated by a tool.                                       
//     Changes to this file may cause incorrect behavior and will be lost if    
//     the code is regenerated.                                                 
// </auto-generated>                                                            
//------------------------------------------------------------------------------
#pragma warning disable 436
#pragma warning disable 162
#pragma warning disable 1591
using System;
using Microsoft.Quantum.Core;
using Microsoft.Quantum.Intrinsic;
using Microsoft.Quantum.Simulation.Core;

[assembly: CallableDeclaration("{\"Kind\":{\"Case\":\"Operation\"},\"QualifiedName\":{\"Namespace\":\"QuantumRNG\",\"Name\":\"ApplyDriverHamiltonian\"},\"Attributes\":[],\"Modifiers\":{\"Access\":{\"Case\":\"DefaultAccess\"}},\"SourceFile\":\"D:\\\\QAOA\\\\QuantumRNG\\\\Program.qs\",\"Position\":{\"Item1\":52,\"Item2\":4},\"SymbolRange\":{\"Item1\":{\"Line\":1,\"Column\":11},\"Item2\":{\"Line\":1,\"Column\":33}},\"ArgumentTuple\":{\"Case\":\"QsTuple\",\"Fields\":[[{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"time\"]},\"Type\":{\"Case\":\"Double\"},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":1,\"Column\":34},\"Item2\":{\"Line\":1,\"Column\":38}}}]},{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"target\"]},\"Type\":{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Qubit\"}]},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":1,\"Column\":48},\"Item2\":{\"Line\":1,\"Column\":54}}}]}]]},\"Signature\":{\"TypeParameters\":[],\"ArgumentType\":{\"Case\":\"TupleType\",\"Fields\":[[{\"Case\":\"Double\"},{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Qubit\"}]}]]},\"ReturnType\":{\"Case\":\"UnitType\"},\"Information\":{\"Characteristics\":{\"Case\":\"Union\",\"Fields\":[{\"Case\":\"SimpleSet\",\"Fields\":[{\"Case\":\"Adjointable\"}]},{\"Case\":\"SimpleSet\",\"Fields\":[{\"Case\":\"Controllable\"}]}]},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}}},\"Documentation\":[\" # Summary\",\" This operation applies the X-rotation to each qubit. We can think of it as time\",\" evolution induced by applying a Hamiltonian that sums over all X rotations.\",\"\",\" # Description\",\" The driver Hamiltonian is defined as:\",\"    H = - \\\\sum_i X_i for time t.\",\"\",\" # Input\",\" ## time\",\" Time passed in evolution of X rotation\",\" ## target\",\" Target qubit register\"]}")]
[assembly: SpecializationDeclaration("{\"Kind\":{\"Case\":\"QsBody\"},\"TypeArguments\":{\"Case\":\"Null\"},\"Information\":{\"Characteristics\":{\"Case\":\"Union\",\"Fields\":[{\"Case\":\"SimpleSet\",\"Fields\":[{\"Case\":\"Adjointable\"}]},{\"Case\":\"SimpleSet\",\"Fields\":[{\"Case\":\"Controllable\"}]}]},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}},\"Parent\":{\"Namespace\":\"QuantumRNG\",\"Name\":\"ApplyDriverHamiltonian\"},\"Attributes\":[],\"SourceFile\":\"D:\\\\QAOA\\\\QuantumRNG\\\\Program.qs\",\"Position\":{\"Item1\":52,\"Item2\":4},\"HeaderRange\":{\"Item1\":{\"Line\":1,\"Column\":11},\"Item2\":{\"Line\":1,\"Column\":33}},\"Documentation\":[]}")]
[assembly: SpecializationDeclaration("{\"Kind\":{\"Case\":\"QsAdjoint\"},\"TypeArguments\":{\"Case\":\"Null\"},\"Information\":{\"Characteristics\":{\"Case\":\"Union\",\"Fields\":[{\"Case\":\"SimpleSet\",\"Fields\":[{\"Case\":\"Adjointable\"}]},{\"Case\":\"SimpleSet\",\"Fields\":[{\"Case\":\"Controllable\"}]}]},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}},\"Parent\":{\"Namespace\":\"QuantumRNG\",\"Name\":\"ApplyDriverHamiltonian\"},\"Attributes\":[],\"SourceFile\":\"D:\\\\QAOA\\\\QuantumRNG\\\\Program.qs\",\"Position\":{\"Item1\":52,\"Item2\":4},\"HeaderRange\":{\"Item1\":{\"Line\":1,\"Column\":75},\"Item2\":{\"Line\":1,\"Column\":84}},\"Documentation\":[\"automatically generated QsAdjoint specialization for QuantumRNG.ApplyDriverHamiltonian\"]}")]
[assembly: SpecializationDeclaration("{\"Kind\":{\"Case\":\"QsControlled\"},\"TypeArguments\":{\"Case\":\"Null\"},\"Information\":{\"Characteristics\":{\"Case\":\"Union\",\"Fields\":[{\"Case\":\"SimpleSet\",\"Fields\":[{\"Case\":\"Adjointable\"}]},{\"Case\":\"SimpleSet\",\"Fields\":[{\"Case\":\"Controllable\"}]}]},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}},\"Parent\":{\"Namespace\":\"QuantumRNG\",\"Name\":\"ApplyDriverHamiltonian\"},\"Attributes\":[],\"SourceFile\":\"D:\\\\QAOA\\\\QuantumRNG\\\\Program.qs\",\"Position\":{\"Item1\":52,\"Item2\":4},\"HeaderRange\":{\"Item1\":{\"Line\":1,\"Column\":75},\"Item2\":{\"Line\":1,\"Column\":84}},\"Documentation\":[\"automatically generated QsControlled specialization for QuantumRNG.ApplyDriverHamiltonian\"]}")]
[assembly: SpecializationDeclaration("{\"Kind\":{\"Case\":\"QsControlledAdjoint\"},\"TypeArguments\":{\"Case\":\"Null\"},\"Information\":{\"Characteristics\":{\"Case\":\"Union\",\"Fields\":[{\"Case\":\"SimpleSet\",\"Fields\":[{\"Case\":\"Adjointable\"}]},{\"Case\":\"SimpleSet\",\"Fields\":[{\"Case\":\"Controllable\"}]}]},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}},\"Parent\":{\"Namespace\":\"QuantumRNG\",\"Name\":\"ApplyDriverHamiltonian\"},\"Attributes\":[],\"SourceFile\":\"D:\\\\QAOA\\\\QuantumRNG\\\\Program.qs\",\"Position\":{\"Item1\":52,\"Item2\":4},\"HeaderRange\":{\"Item1\":{\"Line\":1,\"Column\":75},\"Item2\":{\"Line\":1,\"Column\":84}},\"Documentation\":[\"automatically generated QsControlledAdjoint specialization for QuantumRNG.ApplyDriverHamiltonian\"]}")]
[assembly: CallableDeclaration("{\"Kind\":{\"Case\":\"Operation\"},\"QualifiedName\":{\"Namespace\":\"QuantumRNG\",\"Name\":\"ApplyInstanceHamiltonian\"},\"Attributes\":[],\"Modifiers\":{\"Access\":{\"Case\":\"DefaultAccess\"}},\"SourceFile\":\"D:\\\\QAOA\\\\QuantumRNG\\\\Program.qs\",\"Position\":{\"Item1\":78,\"Item2\":4},\"SymbolRange\":{\"Item1\":{\"Line\":1,\"Column\":11},\"Item2\":{\"Line\":1,\"Column\":35}},\"ArgumentTuple\":{\"Case\":\"QsTuple\",\"Fields\":[[{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"numSegments\"]},\"Type\":{\"Case\":\"Int\"},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":2,\"Column\":9},\"Item2\":{\"Line\":2,\"Column\":20}}}]},{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"time\"]},\"Type\":{\"Case\":\"Double\"},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":3,\"Column\":9},\"Item2\":{\"Line\":3,\"Column\":13}}}]},{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"weights\"]},\"Type\":{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Double\"}]},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":4,\"Column\":9},\"Item2\":{\"Line\":4,\"Column\":16}}}]},{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"coupling\"]},\"Type\":{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Double\"}]},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":5,\"Column\":9},\"Item2\":{\"Line\":5,\"Column\":17}}}]},{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"target\"]},\"Type\":{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Qubit\"}]},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":6,\"Column\":9},\"Item2\":{\"Line\":6,\"Column\":15}}}]}]]},\"Signature\":{\"TypeParameters\":[],\"ArgumentType\":{\"Case\":\"TupleType\",\"Fields\":[[{\"Case\":\"Int\"},{\"Case\":\"Double\"},{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Double\"}]},{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Double\"}]},{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Qubit\"}]}]]},\"ReturnType\":{\"Case\":\"UnitType\"},\"Information\":{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}}},\"Documentation\":[\" # Summary\",\" This applies the Z-rotation according to the instance Hamiltonian.\",\" We can think of it as Hamiltonian time evolution for time t induced\",\" by an Ising Hamiltonian. The Ising Hamiltonian sums over all connected\",\" pairs of Pauli-Z operations Z_i and Z_j scaled by a factor J_ij, plus\",\" the sum over all Z_i scaled by a factor h_i.\",\"\",\" # Description\",\" The Ising Hamiltonian is defined as:\",\"     $\\\\sum_ij J_ij Z_i Z_j + \\\\sum_i h_i Z_i$.\",\"\",\" # Input\",\" ## time\",\" Time point in evolution.\",\" ## weights\",\" Ising magnetic field or \\\"weights\\\" encoding the constraints of our\",\" traveling Santa problem.\",\" ## coupling\",\" Ising coupling term or \\\"penalty\\\" encoding the constraints of our\",\" traveling Santa problem.\",\" ## target\",\" Qubit register that encodes the Spin values in the Ising Hamiltonian.\"]}")]
[assembly: SpecializationDeclaration("{\"Kind\":{\"Case\":\"QsBody\"},\"TypeArguments\":{\"Case\":\"Null\"},\"Information\":{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}},\"Parent\":{\"Namespace\":\"QuantumRNG\",\"Name\":\"ApplyInstanceHamiltonian\"},\"Attributes\":[],\"SourceFile\":\"D:\\\\QAOA\\\\QuantumRNG\\\\Program.qs\",\"Position\":{\"Item1\":78,\"Item2\":4},\"HeaderRange\":{\"Item1\":{\"Line\":1,\"Column\":11},\"Item2\":{\"Line\":1,\"Column\":35}},\"Documentation\":[]}")]
[assembly: CallableDeclaration("{\"Kind\":{\"Case\":\"Function\"},\"QualifiedName\":{\"Namespace\":\"QuantumRNG\",\"Name\":\"HamiltonianWeights\"},\"Attributes\":[],\"Modifiers\":{\"Access\":{\"Case\":\"DefaultAccess\"}},\"SourceFile\":\"D:\\\\QAOA\\\\QuantumRNG\\\\Program.qs\",\"Position\":{\"Item1\":116,\"Item2\":4},\"SymbolRange\":{\"Item1\":{\"Line\":1,\"Column\":10},\"Item2\":{\"Line\":1,\"Column\":28}},\"ArgumentTuple\":{\"Case\":\"QsTuple\",\"Fields\":[[{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"segmentCosts\"]},\"Type\":{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Double\"}]},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":2,\"Column\":9},\"Item2\":{\"Line\":2,\"Column\":21}}}]},{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"penalty\"]},\"Type\":{\"Case\":\"Double\"},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":3,\"Column\":9},\"Item2\":{\"Line\":3,\"Column\":16}}}]},{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"numSegments\"]},\"Type\":{\"Case\":\"Int\"},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":4,\"Column\":9},\"Item2\":{\"Line\":4,\"Column\":20}}}]}]]},\"Signature\":{\"TypeParameters\":[],\"ArgumentType\":{\"Case\":\"TupleType\",\"Fields\":[[{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Double\"}]},{\"Case\":\"Double\"},{\"Case\":\"Int\"}]]},\"ReturnType\":{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Double\"}]},\"Information\":{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}}},\"Documentation\":[\" # Summary\",\" Calculate Hamiltonian parameters based on the given costs and penalty.\",\"\",\" # Input\",\" ## segmentCosts\",\" Cost values of each segment.\",\" ## penalty\",\" Penalty for cases that don't meet constraints.\",\"\",\" # Output\",\" ## weights\",\" Hamiltonian parameters or \\\"weights\\\" as an array where each element corresponds\",\" to a parameter h_j for qubit state j.\",\" ## numSegments\",\" Number of segments in the graph that describes possible paths.\"]}")]
[assembly: SpecializationDeclaration("{\"Kind\":{\"Case\":\"QsBody\"},\"TypeArguments\":{\"Case\":\"Null\"},\"Information\":{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}},\"Parent\":{\"Namespace\":\"QuantumRNG\",\"Name\":\"HamiltonianWeights\"},\"Attributes\":[],\"SourceFile\":\"D:\\\\QAOA\\\\QuantumRNG\\\\Program.qs\",\"Position\":{\"Item1\":116,\"Item2\":4},\"HeaderRange\":{\"Item1\":{\"Line\":1,\"Column\":10},\"Item2\":{\"Line\":1,\"Column\":28}},\"Documentation\":[]}")]
[assembly: CallableDeclaration("{\"Kind\":{\"Case\":\"Function\"},\"QualifiedName\":{\"Namespace\":\"QuantumRNG\",\"Name\":\"HamiltonianCouplings\"},\"Attributes\":[],\"Modifiers\":{\"Access\":{\"Case\":\"DefaultAccess\"}},\"SourceFile\":\"D:\\\\QAOA\\\\QuantumRNG\\\\Program.qs\",\"Position\":{\"Item1\":141,\"Item2\":4},\"SymbolRange\":{\"Item1\":{\"Line\":1,\"Column\":10},\"Item2\":{\"Line\":1,\"Column\":30}},\"ArgumentTuple\":{\"Case\":\"QsTuple\",\"Fields\":[[{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"penalty\"]},\"Type\":{\"Case\":\"Double\"},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":1,\"Column\":31},\"Item2\":{\"Line\":1,\"Column\":38}}}]},{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"numSegments\"]},\"Type\":{\"Case\":\"Int\"},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":1,\"Column\":49},\"Item2\":{\"Line\":1,\"Column\":60}}}]}]]},\"Signature\":{\"TypeParameters\":[],\"ArgumentType\":{\"Case\":\"TupleType\",\"Fields\":[[{\"Case\":\"Double\"},{\"Case\":\"Int\"}]]},\"ReturnType\":{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Double\"}]},\"Information\":{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}}},\"Documentation\":[\" # Summary\",\" Calculate Hamiltonian coupling parameters based on the given penalty.\",\"\",\" # Input\",\" ## penalty\",\" Penalty for cases that don't meet constraints.\",\" ## numSegments\",\" Number of segments in the graph that describes possible paths.\",\"\",\" # Output\",\" ## coupling\",\" Hamiltonian coupling parameters as an array, where each element corresponds\",\" to a parameter J_ij between qubit states i and j.\"]}")]
[assembly: SpecializationDeclaration("{\"Kind\":{\"Case\":\"QsBody\"},\"TypeArguments\":{\"Case\":\"Null\"},\"Information\":{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}},\"Parent\":{\"Namespace\":\"QuantumRNG\",\"Name\":\"HamiltonianCouplings\"},\"Attributes\":[],\"SourceFile\":\"D:\\\\QAOA\\\\QuantumRNG\\\\Program.qs\",\"Position\":{\"Item1\":141,\"Item2\":4},\"HeaderRange\":{\"Item1\":{\"Line\":1,\"Column\":10},\"Item2\":{\"Line\":1,\"Column\":30}},\"Documentation\":[]}")]
[assembly: CallableDeclaration("{\"Kind\":{\"Case\":\"Operation\"},\"QualifiedName\":{\"Namespace\":\"QuantumRNG\",\"Name\":\"PerformQAOA\"},\"Attributes\":[],\"Modifiers\":{\"Access\":{\"Case\":\"DefaultAccess\"}},\"SourceFile\":\"D:\\\\QAOA\\\\QuantumRNG\\\\Program.qs\",\"Position\":{\"Item1\":171,\"Item2\":4},\"SymbolRange\":{\"Item1\":{\"Line\":1,\"Column\":11},\"Item2\":{\"Line\":1,\"Column\":22}},\"ArgumentTuple\":{\"Case\":\"QsTuple\",\"Fields\":[[{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"numSegments\"]},\"Type\":{\"Case\":\"Int\"},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":2,\"Column\":13},\"Item2\":{\"Line\":2,\"Column\":24}}}]},{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"weights\"]},\"Type\":{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Double\"}]},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":3,\"Column\":13},\"Item2\":{\"Line\":3,\"Column\":20}}}]},{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"couplings\"]},\"Type\":{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Double\"}]},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":4,\"Column\":13},\"Item2\":{\"Line\":4,\"Column\":22}}}]},{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"timeX\"]},\"Type\":{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Double\"}]},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":5,\"Column\":13},\"Item2\":{\"Line\":5,\"Column\":18}}}]},{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"timeZ\"]},\"Type\":{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Double\"}]},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":6,\"Column\":13},\"Item2\":{\"Line\":6,\"Column\":18}}}]}]]},\"Signature\":{\"TypeParameters\":[],\"ArgumentType\":{\"Case\":\"TupleType\",\"Fields\":[[{\"Case\":\"Int\"},{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Double\"}]},{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Double\"}]},{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Double\"}]},{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Double\"}]}]]},\"ReturnType\":{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Bool\"}]},\"Information\":{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}}},\"Documentation\":[\" # Summary\",\" Perform the QAOA algorithm for this Ising Hamiltonian\",\"\",\" # Input\",\" ## numSegments\",\" Number of segments in graph\",\" ## weights\",\" Instance Hamiltonian parameters or \\\"weights\\\" as an array where each\",\" element corresponds to a parameter h_j for qubit state j.\",\" ## couplings\",\" Instance Hamiltonian coupling parameters as an array, where each\",\" element corresponds to a parameter J_ij between qubit states i and j.\",\" ## timeX\",\" Time evolution for PauliX operations\",\" ## timeZ\",\" Time evolution for PauliX operations\"]}")]
[assembly: SpecializationDeclaration("{\"Kind\":{\"Case\":\"QsBody\"},\"TypeArguments\":{\"Case\":\"Null\"},\"Information\":{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}},\"Parent\":{\"Namespace\":\"QuantumRNG\",\"Name\":\"PerformQAOA\"},\"Attributes\":[],\"SourceFile\":\"D:\\\\QAOA\\\\QuantumRNG\\\\Program.qs\",\"Position\":{\"Item1\":171,\"Item2\":4},\"HeaderRange\":{\"Item1\":{\"Line\":1,\"Column\":11},\"Item2\":{\"Line\":1,\"Column\":22}},\"Documentation\":[]}")]
[assembly: CallableDeclaration("{\"Kind\":{\"Case\":\"Function\"},\"QualifiedName\":{\"Namespace\":\"QuantumRNG\",\"Name\":\"CalculatedCost\"},\"Attributes\":[],\"Modifiers\":{\"Access\":{\"Case\":\"DefaultAccess\"}},\"SourceFile\":\"D:\\\\QAOA\\\\QuantumRNG\\\\Program.qs\",\"Position\":{\"Item1\":203,\"Item2\":4},\"SymbolRange\":{\"Item1\":{\"Line\":1,\"Column\":10},\"Item2\":{\"Line\":1,\"Column\":24}},\"ArgumentTuple\":{\"Case\":\"QsTuple\",\"Fields\":[[{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"segmentCosts\"]},\"Type\":{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Double\"}]},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":1,\"Column\":25},\"Item2\":{\"Line\":1,\"Column\":37}}}]},{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"usedSegments\"]},\"Type\":{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Bool\"}]},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":1,\"Column\":50},\"Item2\":{\"Line\":1,\"Column\":62}}}]}]]},\"Signature\":{\"TypeParameters\":[],\"ArgumentType\":{\"Case\":\"TupleType\",\"Fields\":[[{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Double\"}]},{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Bool\"}]}]]},\"ReturnType\":{\"Case\":\"Double\"},\"Information\":{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}}},\"Documentation\":[\" # Summary\",\" Calculate the total cost for the given result.\",\"\",\" # Input\",\" ## segmentCosts\",\" Array of costs per segment\",\" ## usedSegments\",\" Array of which segments are used\",\"\",\" # Output\",\" ## finalCost\",\" Calculated cost of given path\"]}")]
[assembly: SpecializationDeclaration("{\"Kind\":{\"Case\":\"QsBody\"},\"TypeArguments\":{\"Case\":\"Null\"},\"Information\":{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}},\"Parent\":{\"Namespace\":\"QuantumRNG\",\"Name\":\"CalculatedCost\"},\"Attributes\":[],\"SourceFile\":\"D:\\\\QAOA\\\\QuantumRNG\\\\Program.qs\",\"Position\":{\"Item1\":203,\"Item2\":4},\"HeaderRange\":{\"Item1\":{\"Line\":1,\"Column\":10},\"Item2\":{\"Line\":1,\"Column\":24}},\"Documentation\":[]}")]
[assembly: CallableDeclaration("{\"Kind\":{\"Case\":\"Function\"},\"QualifiedName\":{\"Namespace\":\"QuantumRNG\",\"Name\":\"IsSatisfactory\"},\"Attributes\":[],\"Modifiers\":{\"Access\":{\"Case\":\"DefaultAccess\"}},\"SourceFile\":\"D:\\\\QAOA\\\\QuantumRNG\\\\Program.qs\",\"Position\":{\"Item1\":225,\"Item2\":4},\"SymbolRange\":{\"Item1\":{\"Line\":1,\"Column\":10},\"Item2\":{\"Line\":1,\"Column\":24}},\"ArgumentTuple\":{\"Case\":\"QsTuple\",\"Fields\":[[{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"numSegments\"]},\"Type\":{\"Case\":\"Int\"},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":1,\"Column\":25},\"Item2\":{\"Line\":1,\"Column\":36}}}]},{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"usedSegments\"]},\"Type\":{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Bool\"}]},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":1,\"Column\":43},\"Item2\":{\"Line\":1,\"Column\":55}}}]}]]},\"Signature\":{\"TypeParameters\":[],\"ArgumentType\":{\"Case\":\"TupleType\",\"Fields\":[[{\"Case\":\"Int\"},{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Bool\"}]}]]},\"ReturnType\":{\"Case\":\"Bool\"},\"Information\":{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}}},\"Documentation\":[\" # Summary\",\" Final check to determine if the used segments satisfy our known\",\" constraints. This function is implemented to consider a graph with 6\",\" segments and three valid connected paths.\",\"\",\" # Input\",\" ## numSegments\",\" Number of segments in the graph\",\" ## usedSegments\",\" Array of which segments were used\",\"\",\" # Output\",\" ## output\",\" Boolean value whether the conditions are satisfied.\"]}")]
[assembly: SpecializationDeclaration("{\"Kind\":{\"Case\":\"QsBody\"},\"TypeArguments\":{\"Case\":\"Null\"},\"Information\":{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}},\"Parent\":{\"Namespace\":\"QuantumRNG\",\"Name\":\"IsSatisfactory\"},\"Attributes\":[],\"SourceFile\":\"D:\\\\QAOA\\\\QuantumRNG\\\\Program.qs\",\"Position\":{\"Item1\":225,\"Item2\":4},\"HeaderRange\":{\"Item1\":{\"Line\":1,\"Column\":10},\"Item2\":{\"Line\":1,\"Column\":24}},\"Documentation\":[]}")]
[assembly: CallableDeclaration("{\"Kind\":{\"Case\":\"Operation\"},\"QualifiedName\":{\"Namespace\":\"QuantumRNG\",\"Name\":\"RunQAOATrials\"},\"Attributes\":[{\"TypeId\":{\"Case\":\"Value\",\"Fields\":[{\"Namespace\":\"Microsoft.Quantum.Core\",\"Name\":\"EntryPoint\",\"Range\":{\"Case\":\"Value\",\"Fields\":[{\"Item1\":{\"Line\":1,\"Column\":2},\"Item2\":{\"Line\":1,\"Column\":12}}]}}]},\"TypeIdRange\":{\"Case\":\"Value\",\"Fields\":[{\"Item1\":{\"Line\":1,\"Column\":2},\"Item2\":{\"Line\":1,\"Column\":12}}]},\"Argument\":{\"Item1\":{\"Case\":\"UnitValue\"},\"Item2\":[],\"Item3\":{\"Case\":\"UnitType\"},\"Item4\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Item5\":{\"Case\":\"Value\",\"Fields\":[{\"Item1\":{\"Line\":1,\"Column\":12},\"Item2\":{\"Line\":1,\"Column\":14}}]}},\"Offset\":{\"Item1\":253,\"Item2\":4},\"Comments\":{\"OpeningComments\":[],\"ClosingComments\":[]}}],\"Modifiers\":{\"Access\":{\"Case\":\"DefaultAccess\"}},\"SourceFile\":\"D:\\\\QAOA\\\\QuantumRNG\\\\Program.qs\",\"Position\":{\"Item1\":254,\"Item2\":4},\"SymbolRange\":{\"Item1\":{\"Line\":1,\"Column\":11},\"Item2\":{\"Line\":1,\"Column\":24}},\"ArgumentTuple\":{\"Case\":\"QsTuple\",\"Fields\":[[{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"numTrials\"]},\"Type\":{\"Case\":\"Int\"},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":1,\"Column\":25},\"Item2\":{\"Line\":1,\"Column\":34}}}]}]]},\"Signature\":{\"TypeParameters\":[],\"ArgumentType\":{\"Case\":\"Int\"},\"ReturnType\":{\"Case\":\"String\"},\"Information\":{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}}},\"Documentation\":[\" # Summary\",\" Run QAOA for a given number of trials on 6 qubits. This sample is based\",\" on the Traveling Santa Problem outlined here:\",\"     http://quantumalgorithmzoo.org/traveling_santa/.\",\" Reports on the best itinerary for the Traveling Santa Problem and how\",\" many of the runs resulted in the answer. This should typically return\",\" the optimal solution roughly 71% of the time.\",\"\",\" # Input\",\" ## numTrials\",\" Number of trials to run the QAOA algorithm for.\"]}")]
[assembly: SpecializationDeclaration("{\"Kind\":{\"Case\":\"QsBody\"},\"TypeArguments\":{\"Case\":\"Null\"},\"Information\":{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}},\"Parent\":{\"Namespace\":\"QuantumRNG\",\"Name\":\"RunQAOATrials\"},\"Attributes\":[],\"SourceFile\":\"D:\\\\QAOA\\\\QuantumRNG\\\\Program.qs\",\"Position\":{\"Item1\":254,\"Item2\":4},\"HeaderRange\":{\"Item1\":{\"Line\":1,\"Column\":11},\"Item2\":{\"Line\":1,\"Column\":24}},\"Documentation\":[]}")]
#line hidden
namespace QuantumRNG
{
    [SourceLocation("D:\\QAOA\\QuantumRNG\\Program.qs", OperationFunctor.Body, 53, 79)]
    [SourceLocation("D:\\QAOA\\QuantumRNG\\Program.qs", OperationFunctor.Adjoint, 53, 79)]
    [SourceLocation("D:\\QAOA\\QuantumRNG\\Program.qs", OperationFunctor.Controlled, 53, 79)]
    [SourceLocation("D:\\QAOA\\QuantumRNG\\Program.qs", OperationFunctor.ControlledAdjoint, 53, 79)]
    public partial class ApplyDriverHamiltonian : Unitary<(Double,IQArray<Qubit>)>, ICallable
    {
        public ApplyDriverHamiltonian(IOperationFactory m) : base(m)
        {
        }

        public class In : QTuple<(Double,IQArray<Qubit>)>, IApplyData
        {
            public In((Double,IQArray<Qubit>) data) : base(data)
            {
            }

            System.Collections.Generic.IEnumerable<Qubit> IApplyData.Qubits
            {
                get
                {
                    return ((IApplyData)Data.Item2)?.Qubits;
                }
            }
        }

        String ICallable.Name => "ApplyDriverHamiltonian";
        String ICallable.FullName => "QuantumRNG.ApplyDriverHamiltonian";
        protected IUnitary Microsoft__Quantum__Canon__ApplyToEachCA
        {
            get;
            set;
        }

        protected IUnitary<(Double,Qubit)> Rx__
        {
            get;
            set;
        }

        public override Func<(Double,IQArray<Qubit>), QVoid> __Body__ => (__in__) =>
        {
            var (time,target) = __in__;
#line 54 "D:\\QAOA\\QuantumRNG\\Program.qs"
            Microsoft__Quantum__Canon__ApplyToEachCA.Apply((Rx__.Partial(new Func<Qubit, (Double,Qubit)>((__arg1__) => ((-(2D) * time), __arg1__))), target));
#line hidden
            return QVoid.Instance;
        }

        ;
        public override Func<(Double,IQArray<Qubit>), QVoid> __AdjointBody__ => (__in__) =>
        {
            var (time,target) = __in__;
#line 53 "D:\\QAOA\\QuantumRNG\\Program.qs"
            Microsoft__Quantum__Canon__ApplyToEachCA.Adjoint.Apply((Rx__.Partial(new Func<Qubit, (Double,Qubit)>((__arg1__) => ((-(2D) * time), __arg1__))), target));
#line hidden
            return QVoid.Instance;
        }

        ;
        public override Func<(IQArray<Qubit>,(Double,IQArray<Qubit>)), QVoid> __ControlledBody__ => (__in__) =>
        {
            var (__controlQubits__,(time,target)) = __in__;
#line 53 "D:\\QAOA\\QuantumRNG\\Program.qs"
            Microsoft__Quantum__Canon__ApplyToEachCA.Controlled.Apply((__controlQubits__, (Rx__.Partial(new Func<Qubit, (Double,Qubit)>((__arg1__) => ((-(2D) * time), __arg1__))), target)));
#line hidden
            return QVoid.Instance;
        }

        ;
        public override Func<(IQArray<Qubit>,(Double,IQArray<Qubit>)), QVoid> __ControlledAdjointBody__ => (__in__) =>
        {
            var (__controlQubits__,(time,target)) = __in__;
#line 53 "D:\\QAOA\\QuantumRNG\\Program.qs"
            Microsoft__Quantum__Canon__ApplyToEachCA.Adjoint.Controlled.Apply((__controlQubits__, (Rx__.Partial(new Func<Qubit, (Double,Qubit)>((__arg1__) => ((-(2D) * time), __arg1__))), target)));
#line hidden
            return QVoid.Instance;
        }

        ;
        public override void __Init__()
        {
            this.Microsoft__Quantum__Canon__ApplyToEachCA = this.__Factory__.Get<IUnitary>(typeof(global::Microsoft.Quantum.Canon.ApplyToEachCA<>));
            this.Rx__ = this.__Factory__.Get<IUnitary<(Double,Qubit)>>(typeof(global::Microsoft.Quantum.Intrinsic.Rx));
        }

        public override IApplyData __DataIn__((Double,IQArray<Qubit>) data) => new In(data);
        public override IApplyData __DataOut__(QVoid data) => data;
        public static System.Threading.Tasks.Task<QVoid> Run(IOperationFactory __m__, Double time, IQArray<Qubit> target)
        {
            return __m__.Run<ApplyDriverHamiltonian, (Double,IQArray<Qubit>), QVoid>((time, target));
        }
    }

    [SourceLocation("D:\\QAOA\\QuantumRNG\\Program.qs", OperationFunctor.Body, 79, 117)]
    public partial class ApplyInstanceHamiltonian : Operation<(Int64,Double,IQArray<Double>,IQArray<Double>,IQArray<Qubit>), QVoid>, ICallable
    {
        public ApplyInstanceHamiltonian(IOperationFactory m) : base(m)
        {
        }

        public class In : QTuple<(Int64,Double,IQArray<Double>,IQArray<Double>,IQArray<Qubit>)>, IApplyData
        {
            public In((Int64,Double,IQArray<Double>,IQArray<Double>,IQArray<Qubit>) data) : base(data)
            {
            }

            System.Collections.Generic.IEnumerable<Qubit> IApplyData.Qubits
            {
                get
                {
                    return ((IApplyData)Data.Item5)?.Qubits;
                }
            }
        }

        String ICallable.Name => "ApplyInstanceHamiltonian";
        String ICallable.FullName => "QuantumRNG.ApplyInstanceHamiltonian";
        protected Allocate Allocate__
        {
            get;
            set;
        }

        protected Release Release__
        {
            get;
            set;
        }

        protected ICallable Microsoft__Quantum__Arrays__Zipped
        {
            get;
            set;
        }

        protected IUnitary<(Double,Qubit)> Rz__
        {
            get;
            set;
        }

        protected IUnitary<(Qubit,Qubit)> Microsoft__Quantum__Intrinsic__CNOT
        {
            get;
            set;
        }

        public override Func<(Int64,Double,IQArray<Double>,IQArray<Double>,IQArray<Qubit>), QVoid> __Body__ => (__in__) =>
        {
            var (numSegments,time,weights,coupling,target) = __in__;
#line hidden
            {
#line 86 "D:\\QAOA\\QuantumRNG\\Program.qs"
                var auxiliary = Allocate__.Apply();
#line hidden
                bool __arg1__ = true;
                try
                {
#line 87 "D:\\QAOA\\QuantumRNG\\Program.qs"
                    foreach (var (h,qubit) in Microsoft__Quantum__Arrays__Zipped.Apply<IQArray<(Double,Qubit)>>((weights, target)))
#line hidden
                    {
#line 88 "D:\\QAOA\\QuantumRNG\\Program.qs"
                        Rz__.Apply((((2D * time) * h), qubit));
                    }

#line 90 "D:\\QAOA\\QuantumRNG\\Program.qs"
                    foreach (var i in new QRange(0L, 5L))
#line hidden
                    {
#line 91 "D:\\QAOA\\QuantumRNG\\Program.qs"
                        foreach (var j in new QRange((i + 1L), 5L))
#line hidden
                        {
#line 93 "D:\\QAOA\\QuantumRNG\\Program.qs"
                            Microsoft__Quantum__Intrinsic__CNOT.Apply((target[i], auxiliary));
#line 94 "D:\\QAOA\\QuantumRNG\\Program.qs"
                            Microsoft__Quantum__Intrinsic__CNOT.Apply((target[j], auxiliary));
#line 96 "D:\\QAOA\\QuantumRNG\\Program.qs"
                            Rz__.Apply((((2D * time) * coupling[((numSegments * i) + j)]), auxiliary));
#line 79 "D:\\QAOA\\QuantumRNG\\Program.qs"
                            Microsoft__Quantum__Intrinsic__CNOT.Adjoint.Apply((target[j], auxiliary));
#line 79 "D:\\QAOA\\QuantumRNG\\Program.qs"
                            Microsoft__Quantum__Intrinsic__CNOT.Adjoint.Apply((target[i], auxiliary));
                        }
                    }
                }
#line hidden
                catch
                {
                    __arg1__ = false;
                    throw;
                }
#line hidden
                finally
                {
                    if (__arg1__)
                    {
#line hidden
                        Release__.Apply(auxiliary);
                    }
                }
            }

#line hidden
            return QVoid.Instance;
        }

        ;
        public override void __Init__()
        {
            this.Allocate__ = this.__Factory__.Get<Allocate>(typeof(global::Microsoft.Quantum.Intrinsic.Allocate));
            this.Release__ = this.__Factory__.Get<Release>(typeof(global::Microsoft.Quantum.Intrinsic.Release));
            this.Microsoft__Quantum__Arrays__Zipped = this.__Factory__.Get<ICallable>(typeof(global::Microsoft.Quantum.Arrays.Zipped<,>));
            this.Rz__ = this.__Factory__.Get<IUnitary<(Double,Qubit)>>(typeof(global::Microsoft.Quantum.Intrinsic.Rz));
            this.Microsoft__Quantum__Intrinsic__CNOT = this.__Factory__.Get<IUnitary<(Qubit,Qubit)>>(typeof(global::Microsoft.Quantum.Intrinsic.CNOT));
        }

        public override IApplyData __DataIn__((Int64,Double,IQArray<Double>,IQArray<Double>,IQArray<Qubit>) data) => new In(data);
        public override IApplyData __DataOut__(QVoid data) => data;
        public static System.Threading.Tasks.Task<QVoid> Run(IOperationFactory __m__, Int64 numSegments, Double time, IQArray<Double> weights, IQArray<Double> coupling, IQArray<Qubit> target)
        {
            return __m__.Run<ApplyInstanceHamiltonian, (Int64,Double,IQArray<Double>,IQArray<Double>,IQArray<Qubit>), QVoid>((numSegments, time, weights, coupling, target));
        }
    }

    [SourceLocation("D:\\QAOA\\QuantumRNG\\Program.qs", OperationFunctor.Body, 117, 142)]
    public partial class HamiltonianWeights : Function<(IQArray<Double>,Double,Int64), IQArray<Double>>, ICallable
    {
        public HamiltonianWeights(IOperationFactory m) : base(m)
        {
        }

        public class In : QTuple<(IQArray<Double>,Double,Int64)>, IApplyData
        {
            public In((IQArray<Double>,Double,Int64) data) : base(data)
            {
            }

            System.Collections.Generic.IEnumerable<Qubit> IApplyData.Qubits => null;
        }

        String ICallable.Name => "HamiltonianWeights";
        String ICallable.FullName => "QuantumRNG.HamiltonianWeights";
        public override Func<(IQArray<Double>,Double,Int64), IQArray<Double>> __Body__ => (__in__) =>
        {
            var (segmentCosts,penalty,numSegments) = __in__;
#line 122 "D:\\QAOA\\QuantumRNG\\Program.qs"
            var weights = QArray<Double>.Create(numSegments);
#line 123 "D:\\QAOA\\QuantumRNG\\Program.qs"
            foreach (var i in new QRange(0L, (numSegments - 1L)))
#line hidden
            {
#line 124 "D:\\QAOA\\QuantumRNG\\Program.qs"
                weights.Modify(i, ((4D * penalty) - (0.5D * segmentCosts[i])));
            }

#line 126 "D:\\QAOA\\QuantumRNG\\Program.qs"
            return weights;
        }

        ;
        public override void __Init__()
        {
        }

        public override IApplyData __DataIn__((IQArray<Double>,Double,Int64) data) => new In(data);
        public override IApplyData __DataOut__(IQArray<Double> data) => data;
        public static System.Threading.Tasks.Task<IQArray<Double>> Run(IOperationFactory __m__, IQArray<Double> segmentCosts, Double penalty, Int64 numSegments)
        {
            return __m__.Run<HamiltonianWeights, (IQArray<Double>,Double,Int64), IQArray<Double>>((segmentCosts, penalty, numSegments));
        }
    }

    [SourceLocation("D:\\QAOA\\QuantumRNG\\Program.qs", OperationFunctor.Body, 142, 172)]
    public partial class HamiltonianCouplings : Function<(Double,Int64), IQArray<Double>>, ICallable
    {
        public HamiltonianCouplings(IOperationFactory m) : base(m)
        {
        }

        public class In : QTuple<(Double,Int64)>, IApplyData
        {
            public In((Double,Int64) data) : base(data)
            {
            }

            System.Collections.Generic.IEnumerable<Qubit> IApplyData.Qubits => null;
        }

        String ICallable.Name => "HamiltonianCouplings";
        String ICallable.FullName => "QuantumRNG.HamiltonianCouplings";
        protected ICallable<(Int64,Int64,String), QVoid> Microsoft__Quantum__Diagnostics__EqualityFactI
        {
            get;
            set;
        }

        protected ICallable Microsoft__Quantum__Arrays__ConstantArray
        {
            get;
            set;
        }

        public override Func<(Double,Int64), IQArray<Double>> __Body__ => (__in__) =>
        {
            var (penalty,numSegments) = __in__;
#line 147 "D:\\QAOA\\QuantumRNG\\Program.qs"
            Microsoft__Quantum__Diagnostics__EqualityFactI.Apply((numSegments, 6L, "Currently, HamiltonianCouplings only supports given constraints for 6 segments."));
#line 150 "D:\\QAOA\\QuantumRNG\\Program.qs"
            return new QArray<Double>(new QArray<Double>(new QArray<Double>(Microsoft__Quantum__Arrays__ConstantArray.Apply<IQArray<Double>>(((numSegments * numSegments), (2D * penalty)))).Modify(2L, penalty)).Modify(9L, penalty)).Modify(29L, penalty);
        }

        ;
        public override void __Init__()
        {
            this.Microsoft__Quantum__Diagnostics__EqualityFactI = this.__Factory__.Get<ICallable<(Int64,Int64,String), QVoid>>(typeof(global::Microsoft.Quantum.Diagnostics.EqualityFactI));
            this.Microsoft__Quantum__Arrays__ConstantArray = this.__Factory__.Get<ICallable>(typeof(global::Microsoft.Quantum.Arrays.ConstantArray<>));
        }

        public override IApplyData __DataIn__((Double,Int64) data) => new In(data);
        public override IApplyData __DataOut__(IQArray<Double> data) => data;
        public static System.Threading.Tasks.Task<IQArray<Double>> Run(IOperationFactory __m__, Double penalty, Int64 numSegments)
        {
            return __m__.Run<HamiltonianCouplings, (Double,Int64), IQArray<Double>>((penalty, numSegments));
        }
    }

    [SourceLocation("D:\\QAOA\\QuantumRNG\\Program.qs", OperationFunctor.Body, 172, 204)]
    public partial class PerformQAOA : Operation<(Int64,IQArray<Double>,IQArray<Double>,IQArray<Double>,IQArray<Double>), IQArray<Boolean>>, ICallable
    {
        public PerformQAOA(IOperationFactory m) : base(m)
        {
        }

        public class In : QTuple<(Int64,IQArray<Double>,IQArray<Double>,IQArray<Double>,IQArray<Double>)>, IApplyData
        {
            public In((Int64,IQArray<Double>,IQArray<Double>,IQArray<Double>,IQArray<Double>) data) : base(data)
            {
            }

            System.Collections.Generic.IEnumerable<Qubit> IApplyData.Qubits => null;
        }

        String ICallable.Name => "PerformQAOA";
        String ICallable.FullName => "QuantumRNG.PerformQAOA";
        protected ICallable<(Int64,Int64,String), QVoid> Microsoft__Quantum__Diagnostics__EqualityFactI
        {
            get;
            set;
        }

        protected ICallable Length__
        {
            get;
            set;
        }

        protected Allocate Allocate__
        {
            get;
            set;
        }

        protected Release Release__
        {
            get;
            set;
        }

        protected ICallable Microsoft__Quantum__Canon__ApplyToEach
        {
            get;
            set;
        }

        protected IUnitary<Qubit> Microsoft__Quantum__Intrinsic__H
        {
            get;
            set;
        }

        protected ICallable Microsoft__Quantum__Arrays__Zipped
        {
            get;
            set;
        }

        protected ICallable<(Int64,Double,IQArray<Double>,IQArray<Double>,IQArray<Qubit>), QVoid> ApplyInstanceHamiltonian__
        {
            get;
            set;
        }

        protected IUnitary<(Double,IQArray<Qubit>)> ApplyDriverHamiltonian__
        {
            get;
            set;
        }

        protected ICallable<IQArray<Result>, IQArray<Boolean>> Microsoft__Quantum__Convert__ResultArrayAsBoolArray
        {
            get;
            set;
        }

        protected ICallable<IQArray<Qubit>, IQArray<Result>> Microsoft__Quantum__Measurement__MultiM
        {
            get;
            set;
        }

        public override Func<(Int64,IQArray<Double>,IQArray<Double>,IQArray<Double>,IQArray<Double>), IQArray<Boolean>> __Body__ => (__in__) =>
        {
            var (numSegments,weights,couplings,timeX,timeZ) = __in__;
#line 179 "D:\\QAOA\\QuantumRNG\\Program.qs"
            Microsoft__Quantum__Diagnostics__EqualityFactI.Apply((timeX.Length, timeZ.Length, "timeZ and timeX are not the same length"));
#line 182 "D:\\QAOA\\QuantumRNG\\Program.qs"
            var result = QArray<Boolean>.Create(numSegments);
#line hidden
            {
#line 183 "D:\\QAOA\\QuantumRNG\\Program.qs"
                var x = Allocate__.Apply(numSegments);
#line hidden
                bool __arg1__ = true;
                try
                {
#line 184 "D:\\QAOA\\QuantumRNG\\Program.qs"
                    Microsoft__Quantum__Canon__ApplyToEach.Apply((Microsoft__Quantum__Intrinsic__H, x));
#line 185 "D:\\QAOA\\QuantumRNG\\Program.qs"
                    foreach (var (tz,tx) in Microsoft__Quantum__Arrays__Zipped.Apply<IQArray<(Double,Double)>>((timeZ, timeX)))
#line hidden
                    {
#line 186 "D:\\QAOA\\QuantumRNG\\Program.qs"
                        ApplyInstanceHamiltonian__.Apply((numSegments, tz, weights, couplings, x));
#line 187 "D:\\QAOA\\QuantumRNG\\Program.qs"
                        ApplyDriverHamiltonian__.Apply((tx, x));
                    }

#line 189 "D:\\QAOA\\QuantumRNG\\Program.qs"
                    return Microsoft__Quantum__Convert__ResultArrayAsBoolArray.Apply(Microsoft__Quantum__Measurement__MultiM.Apply(x));
                }
#line hidden
                catch
                {
                    __arg1__ = false;
                    throw;
                }
#line hidden
                finally
                {
                    if (__arg1__)
                    {
#line hidden
                        Release__.Apply(x);
                    }
                }
            }
        }

        ;
        public override void __Init__()
        {
            this.Microsoft__Quantum__Diagnostics__EqualityFactI = this.__Factory__.Get<ICallable<(Int64,Int64,String), QVoid>>(typeof(global::Microsoft.Quantum.Diagnostics.EqualityFactI));
            this.Length__ = this.__Factory__.Get<ICallable>(typeof(global::Microsoft.Quantum.Core.Length<>));
            this.Allocate__ = this.__Factory__.Get<Allocate>(typeof(global::Microsoft.Quantum.Intrinsic.Allocate));
            this.Release__ = this.__Factory__.Get<Release>(typeof(global::Microsoft.Quantum.Intrinsic.Release));
            this.Microsoft__Quantum__Canon__ApplyToEach = this.__Factory__.Get<ICallable>(typeof(global::Microsoft.Quantum.Canon.ApplyToEach<>));
            this.Microsoft__Quantum__Intrinsic__H = this.__Factory__.Get<IUnitary<Qubit>>(typeof(global::Microsoft.Quantum.Intrinsic.H));
            this.Microsoft__Quantum__Arrays__Zipped = this.__Factory__.Get<ICallable>(typeof(global::Microsoft.Quantum.Arrays.Zipped<,>));
            this.ApplyInstanceHamiltonian__ = this.__Factory__.Get<ICallable<(Int64,Double,IQArray<Double>,IQArray<Double>,IQArray<Qubit>), QVoid>>(typeof(ApplyInstanceHamiltonian));
            this.ApplyDriverHamiltonian__ = this.__Factory__.Get<IUnitary<(Double,IQArray<Qubit>)>>(typeof(ApplyDriverHamiltonian));
            this.Microsoft__Quantum__Convert__ResultArrayAsBoolArray = this.__Factory__.Get<ICallable<IQArray<Result>, IQArray<Boolean>>>(typeof(global::Microsoft.Quantum.Convert.ResultArrayAsBoolArray));
            this.Microsoft__Quantum__Measurement__MultiM = this.__Factory__.Get<ICallable<IQArray<Qubit>, IQArray<Result>>>(typeof(global::Microsoft.Quantum.Measurement.MultiM));
        }

        public override IApplyData __DataIn__((Int64,IQArray<Double>,IQArray<Double>,IQArray<Double>,IQArray<Double>) data) => new In(data);
        public override IApplyData __DataOut__(IQArray<Boolean> data) => data;
        public static System.Threading.Tasks.Task<IQArray<Boolean>> Run(IOperationFactory __m__, Int64 numSegments, IQArray<Double> weights, IQArray<Double> couplings, IQArray<Double> timeX, IQArray<Double> timeZ)
        {
            return __m__.Run<PerformQAOA, (Int64,IQArray<Double>,IQArray<Double>,IQArray<Double>,IQArray<Double>), IQArray<Boolean>>((numSegments, weights, couplings, timeX, timeZ));
        }
    }

    [SourceLocation("D:\\QAOA\\QuantumRNG\\Program.qs", OperationFunctor.Body, 204, 226)]
    public partial class CalculatedCost : Function<(IQArray<Double>,IQArray<Boolean>), Double>, ICallable
    {
        public CalculatedCost(IOperationFactory m) : base(m)
        {
        }

        public class In : QTuple<(IQArray<Double>,IQArray<Boolean>)>, IApplyData
        {
            public In((IQArray<Double>,IQArray<Boolean>) data) : base(data)
            {
            }

            System.Collections.Generic.IEnumerable<Qubit> IApplyData.Qubits => null;
        }

        String ICallable.Name => "CalculatedCost";
        String ICallable.FullName => "QuantumRNG.CalculatedCost";
        protected ICallable Microsoft__Quantum__Arrays__Zipped
        {
            get;
            set;
        }

        public override Func<(IQArray<Double>,IQArray<Boolean>), Double> __Body__ => (__in__) =>
        {
            var (segmentCosts,usedSegments) = __in__;
#line 205 "D:\\QAOA\\QuantumRNG\\Program.qs"
            var finalCost = 0D;
#line 206 "D:\\QAOA\\QuantumRNG\\Program.qs"
            foreach (var (cost,segment) in Microsoft__Quantum__Arrays__Zipped.Apply<IQArray<(Double,Boolean)>>((segmentCosts, usedSegments)))
#line hidden
            {
#line 207 "D:\\QAOA\\QuantumRNG\\Program.qs"
                finalCost = (finalCost + (segment ? cost : 0D));
            }

#line 209 "D:\\QAOA\\QuantumRNG\\Program.qs"
            return finalCost;
        }

        ;
        public override void __Init__()
        {
            this.Microsoft__Quantum__Arrays__Zipped = this.__Factory__.Get<ICallable>(typeof(global::Microsoft.Quantum.Arrays.Zipped<,>));
        }

        public override IApplyData __DataIn__((IQArray<Double>,IQArray<Boolean>) data) => new In(data);
        public override IApplyData __DataOut__(Double data) => new QTuple<Double>(data);
        public static System.Threading.Tasks.Task<Double> Run(IOperationFactory __m__, IQArray<Double> segmentCosts, IQArray<Boolean> usedSegments)
        {
            return __m__.Run<CalculatedCost, (IQArray<Double>,IQArray<Boolean>), Double>((segmentCosts, usedSegments));
        }
    }

    [SourceLocation("D:\\QAOA\\QuantumRNG\\Program.qs", OperationFunctor.Body, 226, 255)]
    public partial class IsSatisfactory : Function<(Int64,IQArray<Boolean>), Boolean>, ICallable
    {
        public IsSatisfactory(IOperationFactory m) : base(m)
        {
        }

        public class In : QTuple<(Int64,IQArray<Boolean>)>, IApplyData
        {
            public In((Int64,IQArray<Boolean>) data) : base(data)
            {
            }

            System.Collections.Generic.IEnumerable<Qubit> IApplyData.Qubits => null;
        }

        String ICallable.Name => "IsSatisfactory";
        String ICallable.FullName => "QuantumRNG.IsSatisfactory";
        protected ICallable<(Int64,Int64,String), QVoid> Microsoft__Quantum__Diagnostics__EqualityFactI
        {
            get;
            set;
        }

        public override Func<(Int64,IQArray<Boolean>), Boolean> __Body__ => (__in__) =>
        {
            var (numSegments,usedSegments) = __in__;
#line 227 "D:\\QAOA\\QuantumRNG\\Program.qs"
            Microsoft__Quantum__Diagnostics__EqualityFactI.Apply((numSegments, 6L, "Currently, IsSatisfactory only supports constraints for 6 segments."));
#line 230 "D:\\QAOA\\QuantumRNG\\Program.qs"
            var hammingWeight = 0L;
#line 231 "D:\\QAOA\\QuantumRNG\\Program.qs"
            foreach (var segment in usedSegments)
#line hidden
            {
#line 232 "D:\\QAOA\\QuantumRNG\\Program.qs"
                hammingWeight = (hammingWeight + (segment ? 1L : 0L));
            }

#line 234 "D:\\QAOA\\QuantumRNG\\Program.qs"
            if (((((hammingWeight != 4L) || (usedSegments[0L] != usedSegments[2L])) || (usedSegments[1L] != usedSegments[3L])) || (usedSegments[4L] != usedSegments[5L])))
            {
#line 238 "D:\\QAOA\\QuantumRNG\\Program.qs"
                return false;
            }

#line 240 "D:\\QAOA\\QuantumRNG\\Program.qs"
            return true;
        }

        ;
        public override void __Init__()
        {
            this.Microsoft__Quantum__Diagnostics__EqualityFactI = this.__Factory__.Get<ICallable<(Int64,Int64,String), QVoid>>(typeof(global::Microsoft.Quantum.Diagnostics.EqualityFactI));
        }

        public override IApplyData __DataIn__((Int64,IQArray<Boolean>) data) => new In(data);
        public override IApplyData __DataOut__(Boolean data) => new QTuple<Boolean>(data);
        public static System.Threading.Tasks.Task<Boolean> Run(IOperationFactory __m__, Int64 numSegments, IQArray<Boolean> usedSegments)
        {
            return __m__.Run<IsSatisfactory, (Int64,IQArray<Boolean>), Boolean>((numSegments, usedSegments));
        }
    }

    [SourceLocation("D:\\QAOA\\QuantumRNG\\Program.qs", OperationFunctor.Body, 255, -1)]
    public partial class RunQAOATrials : Operation<Int64, String>, ICallable
    {
        public RunQAOATrials(IOperationFactory m) : base(m)
        {
        }

        String ICallable.Name => "RunQAOATrials";
        String ICallable.FullName => "QuantumRNG.RunQAOATrials";
        public static EntryPointInfo<Int64, String> Info => new EntryPointInfo<Int64, String>(typeof(RunQAOATrials));
        protected ICallable<(IQArray<Double>,Double,Int64), IQArray<Double>> HamiltonianWeights__
        {
            get;
            set;
        }

        protected ICallable<(Double,Int64), IQArray<Double>> HamiltonianCouplings__
        {
            get;
            set;
        }

        protected ICallable<(Int64,IQArray<Double>,IQArray<Double>,IQArray<Double>,IQArray<Double>), IQArray<Boolean>> PerformQAOA__
        {
            get;
            set;
        }

        protected ICallable<(IQArray<Double>,IQArray<Boolean>), Double> CalculatedCost__
        {
            get;
            set;
        }

        protected ICallable<(Int64,IQArray<Boolean>), Boolean> IsSatisfactory__
        {
            get;
            set;
        }

        protected ICallable<String, QVoid> Message__
        {
            get;
            set;
        }

        protected ICallable<Double, Double> Microsoft__Quantum__Math__AbsD
        {
            get;
            set;
        }

        protected ICallable<Int64, Double> Microsoft__Quantum__Convert__IntAsDouble
        {
            get;
            set;
        }

        public override Func<Int64, String> __Body__ => (__in__) =>
        {
            var numTrials = __in__;
#line 256 "D:\\QAOA\\QuantumRNG\\Program.qs"
            var penalty = 20D;
#line 257 "D:\\QAOA\\QuantumRNG\\Program.qs"
            var segmentCosts = (IQArray<Double>)new QArray<Double>(4.7D, 9.09D, 9.03D, 5.7D, 8.02D, 1.71D);
#line 258 "D:\\QAOA\\QuantumRNG\\Program.qs"
            var timeX = (IQArray<Double>)new QArray<Double>(0.619193D, 0.742566D, 0.060035D, -(1.568955D), 0.04549D);
#line 259 "D:\\QAOA\\QuantumRNG\\Program.qs"
            var timeZ = (IQArray<Double>)new QArray<Double>(3.182203D, -(1.139045D), 0.221082D, 0.537753D, -(0.417222D));
#line 260 "D:\\QAOA\\QuantumRNG\\Program.qs"
            var limit = 1E-06D;
#line 261 "D:\\QAOA\\QuantumRNG\\Program.qs"
            var numSegments = 6L;
#line 263 "D:\\QAOA\\QuantumRNG\\Program.qs"
            var bestCost = (100D * penalty);
#line 264 "D:\\QAOA\\QuantumRNG\\Program.qs"
            var bestItinerary = new QArray<Boolean>(false, false, false, false, false);
#line 265 "D:\\QAOA\\QuantumRNG\\Program.qs"
            var bestWeight = new QArray<Double>(0D, 0D, 0D, 0D, 0D, 0D);
#line 266 "D:\\QAOA\\QuantumRNG\\Program.qs"
            var bestCouplings = new QArray<Double>(0D, 0D, 0D, 0D, 0D, 0D);
#line 267 "D:\\QAOA\\QuantumRNG\\Program.qs"
            var successNumber = 0L;
#line 269 "D:\\QAOA\\QuantumRNG\\Program.qs"
            var weights = (IQArray<Double>)HamiltonianWeights__.Apply((segmentCosts, penalty, numSegments));
#line 270 "D:\\QAOA\\QuantumRNG\\Program.qs"
            var couplings = (IQArray<Double>)HamiltonianCouplings__.Apply((penalty, numSegments));
#line 272 "D:\\QAOA\\QuantumRNG\\Program.qs"
            foreach (var trial in new QRange(0L, numTrials))
#line hidden
            {
#line 273 "D:\\QAOA\\QuantumRNG\\Program.qs"
                var result = (IQArray<Boolean>)PerformQAOA__.Apply((numSegments, weights, couplings, timeX, timeZ));
#line 280 "D:\\QAOA\\QuantumRNG\\Program.qs"
                var cost = CalculatedCost__.Apply((segmentCosts, result));
#line 281 "D:\\QAOA\\QuantumRNG\\Program.qs"
                var sat = IsSatisfactory__.Apply((numSegments, result));
#line 282 "D:\\QAOA\\QuantumRNG\\Program.qs"
                Message__.Apply(String.Format("result = {0}, cost = {1}, satisfactory = {2}", result, cost, sat));
#line 283 "D:\\QAOA\\QuantumRNG\\Program.qs"
                if (sat)
                {
#line 284 "D:\\QAOA\\QuantumRNG\\Program.qs"
                    if ((cost < (bestCost - limit)))
                    {
#line 286 "D:\\QAOA\\QuantumRNG\\Program.qs"
                        bestCost = cost;
#line 287 "D:\\QAOA\\QuantumRNG\\Program.qs"
                        bestItinerary = new QArray<Boolean>(result);
#line 288 "D:\\QAOA\\QuantumRNG\\Program.qs"
                        successNumber = 1L;
#line 289 "D:\\QAOA\\QuantumRNG\\Program.qs"
                        bestWeight = new QArray<Double>(weights);
#line 290 "D:\\QAOA\\QuantumRNG\\Program.qs"
                        bestCouplings = new QArray<Double>(couplings);
                    }
                    else if ((Microsoft__Quantum__Math__AbsD.Apply((cost - bestCost)) < limit))
                    {
#line 292 "D:\\QAOA\\QuantumRNG\\Program.qs"
                        successNumber = (successNumber + 1L);
                    }
                }
            }

#line 296 "D:\\QAOA\\QuantumRNG\\Program.qs"
            var runPercentage = ((Microsoft__Quantum__Convert__IntAsDouble.Apply(successNumber) * 100D) / Microsoft__Quantum__Convert__IntAsDouble.Apply(numTrials));
#line 297 "D:\\QAOA\\QuantumRNG\\Program.qs"
            Message__.Apply("Simulation is complete\n");
#line 298 "D:\\QAOA\\QuantumRNG\\Program.qs"
            Message__.Apply(String.Format("Best itinerary found: {0}, cost = {1}", bestItinerary, bestCost));
#line 299 "D:\\QAOA\\QuantumRNG\\Program.qs"
            Message__.Apply(String.Format("{0}% of runs found the best itinerary\n", runPercentage));
#line 300 "D:\\QAOA\\QuantumRNG\\Program.qs"
            return String.Format("'status' : 'SUCCESS', 'optimal_solution' : {0}, 'optimal_energy': {1}, 'optimal_parameters': {2} ", bestItinerary, bestCost, bestWeight);
        }

        ;
        public override void __Init__()
        {
            this.HamiltonianWeights__ = this.__Factory__.Get<ICallable<(IQArray<Double>,Double,Int64), IQArray<Double>>>(typeof(HamiltonianWeights));
            this.HamiltonianCouplings__ = this.__Factory__.Get<ICallable<(Double,Int64), IQArray<Double>>>(typeof(HamiltonianCouplings));
            this.PerformQAOA__ = this.__Factory__.Get<ICallable<(Int64,IQArray<Double>,IQArray<Double>,IQArray<Double>,IQArray<Double>), IQArray<Boolean>>>(typeof(PerformQAOA));
            this.CalculatedCost__ = this.__Factory__.Get<ICallable<(IQArray<Double>,IQArray<Boolean>), Double>>(typeof(CalculatedCost));
            this.IsSatisfactory__ = this.__Factory__.Get<ICallable<(Int64,IQArray<Boolean>), Boolean>>(typeof(IsSatisfactory));
            this.Message__ = this.__Factory__.Get<ICallable<String, QVoid>>(typeof(global::Microsoft.Quantum.Intrinsic.Message));
            this.Microsoft__Quantum__Math__AbsD = this.__Factory__.Get<ICallable<Double, Double>>(typeof(global::Microsoft.Quantum.Math.AbsD));
            this.Microsoft__Quantum__Convert__IntAsDouble = this.__Factory__.Get<ICallable<Int64, Double>>(typeof(global::Microsoft.Quantum.Convert.IntAsDouble));
        }

        public override IApplyData __DataIn__(Int64 data) => new QTuple<Int64>(data);
        public override IApplyData __DataOut__(String data) => new QTuple<String>(data);
        public static System.Threading.Tasks.Task<String> Run(IOperationFactory __m__, Int64 numTrials)
        {
            return __m__.Run<RunQAOATrials, Int64, String>(numTrials);
        }
    }
}